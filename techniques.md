  Technique | Problems | Remarks 
--- | --- | --- 
'ending at' | [2262. Total Appeal of A String](https://leetcode.com/problems/total-appeal-of-a-string/submissions/) | 
'combinatorics' | [1643. Kth Smallest Instructions](https://leetcode.com/problems/kth-smallest-instructions/description/) |  key idea is select H and then see how can strings  we can surpass , if k <= that , which we can take, else we take V and alsor educe k by that. |
'segment tree' | [2407. Longest Increasing Subsequence II](https://leetcode.com/problems/longest-increasing-subsequence-ii/description/) | **1** seg tree child index 2* idx+1 and 2 * idx+2   **2**  check for no overlap, complete overlap , else recurse  
' binary lifting ' | [https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)  [https://leetcode.com/problems/kth-ancestor-of-a-tree-node/](https://leetcode.com/problems/kth-ancestor-of-a-tree-node/) &nbsp; [https://leetcode.com/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/](https://leetcode.com/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/) &nbsp; [https://leetcode.com/problems/maximize-value-of-function-in-a-ball-passing-game](https://leetcode.com/problems/maximize-value-of-function-in-a-ball-passing-game)  &nbsp; [https://leetcode.com/problems/cycle-length-queries-in-a-tree/](https://leetcode.com/problems/cycle-length-queries-in-a-tree/) | Parents of power of 2 for each node &nbsp; Core component of LCA are depth/parent & LCA array, if the tree is perfect binary tree, these can be calculated on the fly ratehr than storing in array. Otherwise process is do DFS and populate depth and parent array. Next for each depth (starting from small) calculate higher depth) , LCA of u,v cna be found first getting them at same level and binary search and finding last non-matching. Parent of any of it  would give  LCA.
